#뷰와 윈도우 구조


뷰와 윈도우는 당신의 어플리케이션에서의 UI(User Interface)를 보여주고, UI의 사용자 인터렉션의 처리합니다. UIKit과 다른 시스템 프레임워크는 사용자들이 조금 수정하거나 수정없이 사용할수 있는 수 많은 뷰들을 제공해줍니다.
당신은 또한 표준뷰와 다른 모양의 커스텀뷰를 만들수 도 있습니다. 

당신이 시스템의 뷰를 사용하던지, 커스텀뷰를 만들던지 당신은 UIView와 UIWindow 클래스의 구조를 이해할 필요가 있습니다. 이 클래스들은 레이아웃을 다루고 뷰를 나타내는 세련된 기능들을 제공해줍니다.

이러한 기능들이 어떻게 동작하는지 이해하는것은 당신의 어플리케이션에서 변화가 일어났을때 당신의 뷰들이 적절하게 동작하도록 할 것이기에 중요합니다.


##뷰 구조의 기초

당신이 시각적으로 동작하길 원하는 것들의 대부분은 뷰  UIView 클래스의 인스턴스인 뷰 객체입니다. 뷰객체는 스크린상에서의 직사각형의 영역을 정의하고, 영역안에서 그림과 터치 이벤트를 처리합니다. 뷰는 또한 다른 뷰들의 부모의 역할을 할수 있고 자식뷰들의 배치와 사이즈를 조정할 수 잇습니다. UIView 클래스는 뷰들 사이의 이러한 관계들을 관리하는데 많은 일을 합니다. 하지만 당신은 필요한 경우 이러한 기본 행동들을 커스터마이즈 할 수 있습니다.

뷰는 뷰의 내용물들의 렌더링과 애니메이ㅏ팅을 다루기 위해서 Core Animation layers와 동시에 작동합니다. UIkit의 모든 뷰는 레이어 객체(보통은 CALayer Class의 인스턴스)의 뒤에 있습니다. 이 레이어 객체는  which manages the backing store for the view and 뷰와 관련된 애니메이션을 처리합니다. 당신이 수행하는 대부분의 동작들은 UIView 인터페이스를 통합니다. 하지만 렌더링과 애니메잉션에서 더 많은 작업을 원하는 경우엔 이 레이어 객체를 통해서 작업할 수 잇습니다.

뷰와 레이어의 관계를 이해하기 위해선 다음의 예제를 보는것이 도움이 됩니다. Figure1-1은 [ViewTransition]() 샘플 앱에서의 CALyaer의 관계에 따른 뷰 구조를 보여줍니다. 어플리케이션에서 뷰는 window객체(이것 또한 뷰)와 컨테이너 뷰, 이미지뷰, 툴바, Bar buttion item(view는 아니지만 내부적으론 뷰를 관리함)과 같은 역할을 하는 generic한 UIView객체를 포함하고있습니다. (실제로 [ViewTransitions]() 샘플 어플리케이션은 Transition을 구현한 이미지뷰를 추가적으로 포함하고 있습니다.) 이러한 레이어 객체의 뒤에서 Core Animation은 객체들을 렌더링하고 하드웨어 버퍼는 스크린에 실제 bits를 다루는데 쓰입니다.


Core Animation 레이어 객체를 사용하는것은 퍼포먼스에 중요한 영항을 끼칩니다. 실제적인 뷰 객체를 그리는 코드는 가능한 최소한으로 불려집니다. 그리고 코드가 호출될때, 결과값은 Core Animation에 캐시되고 가능하면 이 후에 재사용 됩니다. 이미 렌더링된 컨텐츠를 재사용함으로써 뷰를 업데이트 할때의 drawing cycle의 비용을 줄여 줍니다. 컨텐츠의 재사용은 특히 애니메이션에서 중요합니다. 애니메이션에서 이미 존재하는 컨텐츠가 다뤄질때 컨텐츠는 재사용될 수 있습니다. 이러한 재사용은 새로운 컨텐츠를 만드는 것보다 훨씬 더 적은 비용이 듭니다.

## 뷰 계층구조와 subView 관리

뷰는 내용을 표시하는거 뿐만 아니라, 다른 뷰의 컨테이너 역할을 할수 있습니다. 하나의 뷰가 다른 뷰를 서브뷰로 가지고 있을때, 둘 사이에는 부모-자식 관계가 만들어 집니다. 이 관계에서 자식뷰는 subView라 하고, 부모뷰는 superView라고 합니다. 이러한 종류의 관계는 당신의 어플리케이션의 시각적인 외관과 어플리케이션의 행동에 영향을 끼칩니다.

시각적으로, subView의 내용은 parent뷰의 내용을 부분 또는 전체를 불분명하게 합니다. 만약에 subView가 전체적으로 불투명하다면, subView의 내용은 같은위치에 잇는 superView의 내용을 완전히 불분명 하게 할것입니다. 만약에 subView가 부분적으로 투명하다면, 두 뷰에 있는 내용은 섞여서 스크린에 표시될 것 입니다. 각각의 superView는 subView들을 배열로 가지고 저장하고 있습니다. 그리고 배열에서의 순서는 각각의 subView들의 외관에 영향을 끼칠수 잇습니다. 만약에 두개의 형제 subView들이 서로를 overlap한다면 배열에서 가장 마지막 순서(가장 마지막에 추가된)인 subView가 위에 보일 것입니다.

superView-subView관계는 또한 몇몇 뷰들의 행동에 영향을 끼칩니다. 부모 뷰의 크기가 변경되면 자식뷰의 크기나 위치에 영향을 끼칠수 있는 약간의 효과를 발생시킬 수 있습니다. 부모뷰의 크기를 변경할때, 자식뷰들 각각을 resize 하도록 조작 할수 있습니다. 또한 superView를 숨기거나, alpha값(투명도)을 변경하거나, 좌표계에 수학적인 변형을 적용하면 자식뷰들에 영향을 끼칩니다.

뷰 계층구조에서 뷰들의 배열은 당신의 어플리케이션이 어떻게 이벤트에 반응할 것인지를 결정합니다. 특정 뷰안에서 터치가 일어났을때, 시스템(iOS)은 터치 정보와 함께 이벤트 객체를 이벤트를 처리할수 있는 뷰에게 직접적으로 보냅니다. 하지만 그 뷰가 터치 이벤트를 처리할 수없다면, 뷰는 터치 이벤트를 객체를 부모뷰에게 보냅니다. 이 과정은 Responder chain에 따라 계속 반복됩니다. 특정 뷰들은 이벤트 객체를 뷰 컨트롤러와 같이 중간에 낀 리스폰더 객체에 보낼 수 도 잇습니다. 만약에 이벤트를 처리할수 있는 뷰가없다면 이벤트 객체는 어플리케이션 객체에 전달되고 일반적으로 무시됩니다.

뷰 계층 구조가 만들어 과정에 대해서 더 많은 정보는 [Creating and Managing a View Hierarchy]에서 볼수 있습니다.

## 뷰 Drawing Cycle

UIViwe 클래스는 내용을 표시하는데 on-demand drawing model을 사용합니다. 뷰가 스크린에 처음 나타나게 되면, 시스템은 뷰에게 내용을 그릴 것을 물어봅니다. 시스템은 이 내용들의 스냅샷을 찍어두고, 스냅샷은 뷰의 시각적인 묘사에 사용됩니다. 만약 당신이 뷰의 내용을 바꾸지 않는다면, 뷰의 drawing code는 다시 호출되지 않을 것입니다. 스냡샷 이미지는 뷰에 관련된 대부분의 작업에서 재사용됩니다. 당신이 뷰의 내용을 바꾼다면, 당신은 시스템에게 뷰가 바뀌었다고 알려줍니다. 그러면 뷰는 뷰를 그리고 결과의 스냅샷을 찍는 프로세스를 반복합니다.
 

당신의 뷰의 내용이 변경되면, 당신은 변경사항을 직접적으로 다시 그리면 안됩니다. 대신에 당신은 [setNeedsDisplay](), [setNeetdsDisplayInRect:]()를 사용해서 뷰를 invalidate 시킬 수 있습니다. 이러한 메소드들은 시스템에게 뷰의 내용이 바뀌었고, 다음기회에 다시그려줘야 한다고 알려줍니다. 시스템은 drwaing작업을 시작하기 전에 현재의 run loop가 끝날때까지 기다립니다. 이러한 딜레이동안 당신은 많은 뷰들을 invalidate 시키거나, 뷰계층구조에 뷰들을 추가하고 삭제할 수 있고 또한 뷰를 숨기거나 사이즈를 변경하거나 위치를 변경할 수 있습니다. 이러한 변경사항은 그때 동시에 반영이 됩니다.

> 뷰의 기하학적인 요소를 변경하는것은 시스템에게 뷰의 내용을 다시 그리라는 메시지를 주지 못합니다. 뷰의 contentMode 프로퍼티는 어떻게 뷰의 기학학요소 변경사항이 해석되어야 되는지 결정해줍니다. 대부분의 contentMode는 뷰의 범위 내에서 stertch나 position을 변경하고 새로 만들지는 않습니다. contentMode가 뷰의 drawing cycle에 어떻게 영향을 주는지가 궁금하다면  다음을 보세요

당신의 뷰의 내용을 render할때, 실제로 그려지는 과정은 뷰와 뷰의 설정에 따라서 다릅니다. 시스템 뷰는 일반적으로 내용을 render하기위한 private method를 구현하고 있습니다. Those same system views often expose interfaces that you can use to configure the view’s actual appearance. 이 동일한 시스템 뷰들은 종종 뷰의 외관을 구성하는데 사용할 수 있는 인터페이스를 노출합니다. UIView 클래스를 상속받는 커스텀 클래스에서, 당신은 일반적으로 [drawRect:]() 메소드를 오버라이드 할수 있고 뷰의 내용을 그리는데 사용할 수 있습니다. 또한 뷰의 내용을 표시하는데에는 다른 방법들이 있습니다. 바로밑에 있는 layer로 내용을 설정할 수 도 있습니다. 하지만 일반적으론 drawRect: 메소드를 사용합니다.
뷰의 내용을 표시하는 더 많은정보는 여기를 참고하세요. [Implemeting Your Drawing Code.]()

### Content Modes

각각의 뷰는 content mode 속성을 가지고 있습니다. content mode는 뷰의 기하학적인 변화에 따라서 content를 어떻게 재사용하는 방법을 제어합니다. 또한 뷰의 내용을 재사용할 것인지, 새로 만들 것인지를 결정합니다. 뷰가 처음으로 화면에 표시될때, 뷰는 내용을 평소와 같이 그립니다. 그리고 그려진 결과는 기본적인 bitmap으로 캡쳐 됩니다. 그 후에, 뷰의 기하학적인 변화로 항상 비트맵이 다시 만들어지지 않습니다. 대신에 contentMode 속성값이 비트맵이 새로운 경계에 맞게 확대/축소 되어야 되는지를 결정합니다.  
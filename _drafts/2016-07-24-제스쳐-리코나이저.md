---
layout: post
title:  "Gesture Recongnizer"
date:   2016-07-24 21:00:00
category: iOS
tags: iOS-Docs

### At a Glance

이벤트는 앱에게 사용자 액션의 정보를 전달하는 개체이다. iOS에서, 이벤트는 매우 다양한 형태로 존재한다
- 멀티 터치 이벤트
- 모션 이벤트는
- 멀티미디어를 다루는 이벤트 등.
- 원격조종 이벤트(외부 악세사리로 동작하는 이벤트)

### UIKit Makes It Easy for Your App to Dectect Gestures
iOS 앱은 터치들의 조합을 인식하고 사용자가에 직관적인방법으로 그들에 대해 응답해준다. 예를들면 핀칭 제스쳐에 내용을 줌인(확대) 하도록, 플리킹 제스쳐에는 내용을 스크롤링 하도록 반응한다. 실제론, UIkit에 포함된 몇몇의 제스쳐들은 똑같다. 예를들어서 설명하면, UIControl의 하위클래스인 UIButton과 UISlider 는 특정한 제스쳐에 반응한다.
- 버튼에 탭, 슬라이더의 드래그

당신이 이러한 컨트롤들을 설정하면, 그들은 터치가 일어났을때 타겟 객체에게 액션메시지를 보낸다. 당신은 도한 제스쳐 리코나이저를 사용해서 뷰에 타겟-액션 메카니즘을 적용할 수 도 있다. 당신이 뷰에 제스쳐리코나이저를 붙인다면, 전체적인 뷰는 마치 컨트롤-제스쳐에대한 리스폰딩으로 행동할 거다.



제스쳐 리코나이져는 복잡한 이벤트 핸들링 로직의 상위레벨의 추상화를 제공해준다. 제스쳐리코나이져는 당신의 앱에서 터치이벤트 핸들링을 할때 선호되는 방식이다. 제스쳐 리코나이저는 매우 강력하고, 재사용이 가능하고, 유연하기 때문이다. 당신은 내장된 제스쳐 리코나이져를 사용할수도 있고 행동을 커스텀할수도 있다. 또는 당신은 새로운 제스쳐를 인식하는 제스쳐리코나이저를 만들수도 있다.





### UIControl

	UIResponder
		|- UIView
	  		|- UIButton

UIControl 클래스는 사용자 인터랙션의 응답으로 특정한 액션 또는 의도를 전달하는 시작적인 요소의 공통적인 행동을 구현한다. 컨트롤은 버튼과 슬라이더 같이 앱의 navigation 수월하게하고 사용자입력을 모으거나 컨텐츠를 생산하는데에 쓸수 있다.
당신은 이클래스로 부터 인스터를 직접적으로 만들면 안된다. UIControl클래스는 당신이 커스텀 클래스를 구현하고자 확장하려는서브클래싱 포인트이다. 당신은 또한 그들의 행동을 조작하거나 확장하기위해 이미 존재하는 컨트롤클래스들을  서브클래싱할수 있다. 
예를들면 당신은 메소드들을 당신의 터치이벤트를 트래킹하도록 메소드들을 재정의할수 있고, 언제 그들의 상태가 바뀔찌 결정할 수 있다.  

컨트롤의 상태는 그것의 외관과 사용자 인터렉션을 도와주는 능력을 결정할 수있다. 컨트롤은 몇가지 상태중에 한가지가 될수 있고, 이는 [UIControlState]()에 정의되어 있다 당신은 컨트롤의 상태를 프로그래밍으로 바꿀수 있다. 예를 들면 당신은 컨트롤을 사용자 인터랙션을 막기위해 불가능하게 할 수 있다. 사용자 인터랙션 또한 컨트롤의 상태를 변경 할 수 있다.

### Gesture Recognizers
제스쳐 리코나이저는 하위레벨의 이벤트처리 코드를 상위레벨의 액션으로 바꿔준다. 이들은 뷰에 부착되는 객체이고, 뷰가 그들이 다루는 컨트롤이 하는 방식과 같이 액션에 응답할 수 있게 한다. 제스쳐 리코나이저는 특정한 제스쳐(스와이프, 핀치, 회전)에 응답하는지를 결정하기위해 터치를 해석한다. 일반적으로 타겟 객체는 뷰의 뷰컨트롤러이다. 이러한 디자인 패턴은 매우 파워풀하고 간단하다. 당신은 동적으로 어떤 액션이 뷰에 반응해야하는지 결정할수 잇고 뷰의 서브클래스를 만들지 않고 제스쳐 리코나이저를 넣을 수도 있다.

### Gesture Recogzniers Interpret Raw Touche Events
제스쳐 리코나이저는 Raw 터치 이벤트를 해석함

당신은 어떻게 앱이 제스쳐를 인식하고 응답하는지 배웠을 것이다. 하지만 커스텀 제스쳐리코나이저를 만들거나 뷰의 터치 이벤트 핸들링과 어떻게 상호작용하는지를 컨트롤하기위해선 당신은 터치와 이벤트에 관해 좀더 생각할 필요가 있다.

### An Event Contains All the Touches for the Current Multitouch Sequece
iOS에서, 터치는 스크린에 손가락을 올리거나 움직이는 것이다. 제스쳐 는 하나이상의 터치를 가질수 잇고 이는 UITouch 객체로 표현된다. 예를들면 pinch-close 제스쳐는 두개의 터치를 가지고 있다. 

하나의 이벤트가 멀티터치 시퀀스 동안의 모든 터치들 가지고 있다. 멀티터치 시퀀스는 하나의 손가락이 스크린에 올려져 있을때 시작되고 마지막 손가락이 스크린을 떠날때까지 종료된다. 손가락을 움직이면, iOS는 터치 객체를 이벤트에 보낸다. 멀티 터치이벤트는 UIVent객체의 UIEventTypeTouches타입으로 표현현된다.

각각의 터치 객체는 오로지 하나의 손가락을 따르고 멀티터치 시퀀스가 계속되는한 유지된다. 시퀀스 동안에, UIKit은 손가락을 추적하고 터치 객체의 속성을 업데이트한다. 이러한 속성들은 터치의 Phase, 뷰에서의 위치, 이전 위치, 발생시간 등을 포함한다.

Phase는 언제 터치가 시작했는지, 그것이 움직이고 있는지 정지해있는지, 언제 끝났는지(손가락이 더이상 스크린을 누르고 있지 않는지)를 가리킨다. Figure1-4와 같이 앱은 터치에 대해서 이벤트 객체를 받는다.

> 노트: 손가락은 마우스 포인터보다 덜 정확하다. 사용자가 스크린을 터치했을데, 접촉면적은 실제로 타원형에 가깝고 사용자가 기대하는 것에 비해서 살짝 더낮다. 이 "접촉 패치"는 손가락의 사이즈와 방향에, 누르는 압력의 정도, 몇번째 손가락을 썻는지 등에 따라서 다르다. 현재의 멀티터치 시스템은 이러한 정보를 분석하고 싱글터치 포인트를 계싼한다. 그래서 당신은 이것을 하기위한 코드를 작성할 필요가 없다.




### [Regulating the Delivery of Touches to Views](https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW42)

터치에서 뷰로 가는 전달을 제한하기

제스처 리코나이저 이전에 뷰가 터치를 받기를 원할때가 있다. 그러나 당신이 터치 전달 경로를 바꾸기 전에, 당신은 기본적인 행동에 대해서 이해해야 한다. 간단한 경우에, 터치가 발생했을때 터치 객체는 UIApplication object에서 UIWindow 객체로 전달된다. 그때 윈도우는 우선 해당 터치가 일어난 뷰(또는 그 뷰의 슈퍼뷰)에게 터치 객체를 보내기 전에, 제스쳐 리코나이저에게 터치 객체를 보낸다. 
	
[https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/path_of_touches_2x.png]()

### Gesture Recognizer Get the First Opportunity to Recognize a touch

제스쳐 리코나이저는 터치를 인식할 첫번째 기회를 얻는다.

윈도우객체는 뷰에게 터치객체의 전달하는것을 지연시키고, 제스쳐 리코나이저가 터치를 먼저 분석한다. 이 딜레이 동안에 제스쳐 리코나이저가 터치 제스쳐를 인식했다면, 그때는 윈도우 객체는 그 터치(이전터치)를 뷰에게 전달하지 않는다. 또한 뷰에게 이전에 들어왓었던 모든 터치 객체(이전 인식된 시퀀스들의 부분이 될수 있다)를 취소시킨다. 

예를들면, 당신이 두개의 손가락 터치를 요구하는 Discrete 제스쳐를 갖고 있다고 하자. 이것은 두가지 터치 오브젝트로 나눌 수 있다. 터치가 일어났을때, 앱 객체에서 전돨된 터치 객체는 윈도우 객체에서 터치가 일어난 뷰로 넘겨지게 된다. 그리고 다음의 과정이 진행된다. 
https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/recognize_touch_2x.png

1. 윈도우 객체는 두개의 BeganPhase에 있는 터치 객체를 제스쳐 리코나이저에게 보낸다. - touchesBegan:withEvent: 메소드를 통해서 - 제스쳐 리코나이저 는 아직 제스쳐를 인식하지 못했으므로 이것의 상태값은 Possible이다. 윈도우 객체는 이 두 터치객체를 제스쳐리코나이저가 달려있는 뷰에 보낸다.
2. 윈도우객체는 MovedPhase에 있는 두개의 터치객체를 제스쳐리코나이저에게 보낸다 - touchesMoved:withEvent: 메서드를 통해서 - 제스쳐 리코나이저는 아직까지 제스쳐를 인식하지 못햇으므로 possible상태이다. 윈도우 객체는 그리고나서 이 터치 객체를 뷰에게 보낸다.
3. 윈도우 객체는 하나의 EndPhase에 있는 터치객체를 제스쳐리코나이저에게 보낸다 - touchesEnded:withEvnet:를 통해서 - 이 터치 객체는 이 제스쳐에 필요한 충분한 정보를 주지 못한다. 그러나 윈도우 객체는 해당 뷰에 터치객체를 보내는걸 보류한다.
4. 윈도우 객체는 EndPhase에 있는 다른 하나의 터치 객체를 제스쳐 리코나이저에게 보낸다. 제스쳐 리코나이저는 드디어 자신의 제스쳐를 인식했으므로, 자신의 상태를 Recognized로 변경한다. 첫번째 액션 메ㅐ시지가 보내지기 전에 뷰는 touchesCancelled:withEvent를 호출하여 Began과 Moved Phase에서 온 터치 객체들을 무효화 시킨다. 따라서 EndedPhase에 잇던 touch 객체들은 Cancled된다.

자 그럼,  마지막 스탭에 있던 제스쳐 리코나이저가 이 분석된 멀티터치 시퀀스가 자신의 제스쳐가 아니라고 결정한다고 가정해보자. 그것은 자신의 상태값을를 UIGestureRecognizerStateFailed로 바꾼다. 그때 윈도우 객체는 EndPhase에 있는 투개의 터치 이벤트를 뷰에게 전달한다.  - touchesEnded:withEvent메서드를 통해서 - 
continous 제스쳐 리코나이저도 비슷한 과정을 거친다. 다만 이들은 터치 객체가 EndedPhase에 도달하기 전에 제스쳐를 인식하기 쉽다. 제스쳐가 인식되었는가에 따라서, 그것은 자신의 상태를 UIGestureRecognizerBegan(인식되지 않음)로 바꾼다. 즉, 윈도우 객체는 모든 멀티터치 시퀀스의 순차적인 터치 객체를 제스쳐를 제스쳐 리코나이저에게 보내지만 뷰에게 보내진 않는다.

### Affecting the Delivery of Touches to views

뷰로 가는 터치전달 경로를 바꾸기

당신은 터치 전달경로를 바꾸기위해서 UIGestureRecognizer 프로퍼티의 몇몇 값을 바꿀수 있다. 만약에 당신이 
이 프로퍼티들의 기본값을 변경한다면, 당신은 다음과 같은 차이를 겪게 될것이다.

- dealysTouchesBegan(기본: NO) -- 일반적으로, 윈도우는 Began과 Moved Phase에 있는 터치 객체를 뷰와 제스쳐 리코나이저에게 보낸다. 이 프로퍼티를 YES로 바꾸게 되면 윈도우게 Began phase에 있는 터치 객체가 뷰에 전달되는것을 막아버린다. 이것은 제스쳐 리코나이저가 제스쳐를 인식했을때, 뷰에게 전달되는 모든 터치 이벤틀들 막아버리는 것을 의미한다. 그러나.. 이 프로퍼티를 YES로 변경하면  당신의 인터페이스가 덜 반응형이 될수 있음에 유의해라.
- 이 설정은 UIScrollView의 delayesContentTouces프로퍼티와 비슷한 행동을 한다. 이 경우엔 터치가 시작되면서 곧바로 스크롤이 시작될때, 스크롤뷰의 서브뷰들이 touch이벤트를 받지 못하도록 한다. 따라서 시각적인 효과가 보이지 않게된다.

- delayesTouchesEnded(기본: YES) -- 이 프로퍼티가 YES일때, 뷰는 제스쳐가 이후에 취소하길 원하는 액션을 완수하지 못한다. 제스쳐 리코나이저가 터치 이벤트를 분석할때, 윈도우 객체는 EndPhase에 잇는 터치객체를 뷰에게 보내지 않느다. 만약에 제스쳐리코나이저가 제스쳐를 인식하게 될경우, 터치 객체는 Cancled된다. 만약에 제스쳐 리코나이저가 제스쳐를 인식하지 못했을때, 윈도우 객체는 이들 터치 객체를 touchesEnded메서드를 통해서 보낸다. 이 프로퍼티를 NO로 설정하게 되면 뷰가 EndedPhase에 있는 터치객체를 제스쳐리코나이저와 동시에 분석할 수 있게 한다.
- 다음과 같은 사오항을 생각해보자. 뷰는 두번 탭을 하는 탭 제스쳐 리코나이저를 가지고 있고 사용자는 뷸들 두번 탭했다. 이 프로퍼티 값이 YES일때 뷰는 
		- touchesBegan:withEvent:
		- touchesBegan:withEvent:
		- touchesCancelled:withEvent:
		- touchesCancelled:withEvent:
이벤트를 받게된다.
하지만 이 프로퍼티가 NO일때는, 뷰는
		- touchesBegan:withEvent:
		- touchesEnded:withEvent:
		- touchesBegan:withEvent:
		- touchesCancled:withEvent:
이벤트를 순차적으로 받게 된다. touchesBegan:withEvent:를 두번받게 되면 뷰는 더블탭을 인식한다.

만약에 제스쳐 리코나이저가 자신의 제스쳐와 상관이 없는 터치를 감지하게되면, 그 터치는 뷰로 바로 전달된다. 이걸 하기 위해선 제스쳐리코나이저의 ignoreTouch:forEvent를 호출하면 된다.
	





